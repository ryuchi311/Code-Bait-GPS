<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Secret Locations</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* reuse a few table helpers from admin.html for consistent look */
      .coords { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; font-size: 13px; color:#0b2540 }
      .badge-acc { display:inline-block; padding:4px 8px; border-radius:999px; font-weight:700; font-size:12px; background:#eef2ff; color:#3730a3 }
      .action-btn { border:1px solid rgba(2,6,23,0.06); background:#fafafa; padding:6px 8px; border-radius:8px; font-size:12px; }
      .pv-toast { position: fixed; left: 50%; transform: translateX(-50%); bottom: 20vh; background: rgba(15,23,42,0.95); color: #fff; padding: 8px 12px; border-radius: 8px; box-shadow: 0 6px 18px rgba(2,6,23,0.4); opacity: 0; pointer-events: none; transition: opacity 0.2s, transform 0.2s; }
      .pv-toast.show { opacity: 1; transform: translateX(-50%) translateY(-8px); pointer-events: auto; }
      .pv-table { width:100%; border-collapse:collapse; }
      .pv-table th, .pv-table td { padding:10px; text-align:left; border-bottom:1px solid rgba(2,6,23,0.04); }
      .device-td { color:#0f172a; font-size:13px; }
    </style>
  </head>
  <body class="bg-slate-50 min-h-screen text-slate-800">
    <main class="max-w-6xl mx-auto px-4 py-8">
      <div class="flex items-center justify-between mb-4">
        <h1 class="text-2xl font-semibold">Secret Locations</h1>
  <div class="flex items-center gap-3 text-sm text-slate-600">
          <label for="autoRefreshToggle" class="text-sm">Auto-refresh</label>
          <button id="autoRefreshToggle" role="switch" aria-checked="true" class="relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" aria-pressed="true">
            <span class="sr-only">Toggle auto-refresh</span>
            <span class="toggle-bg block h-6 w-11 rounded-full bg-indigo-600"></span>
            <span class="toggle-knob absolute left-1 inline-block h-4 w-4 transform rounded-full bg-white transition-transform translate-x-5"></span>
          </button>
          <button id="deleteSelected" class="px-3 py-1 bg-red-50 text-red-700 rounded text-sm" title="Delete selected rows">Delete selected</button>
          <button id="clearDeleted" class="px-3 py-1 bg-slate-100 text-slate-700 rounded text-sm" title="Empty deleted.json">Clear deleted</button>
        </div>
      </div>
      <div class="bg-white shadow rounded-lg overflow-hidden">
        <div class="overflow-x-auto">
          <table class="pv-table" id="secretTable">
            <thead>
              <tr>
                <th style="width:48px"><input id="selectAllChk" type="checkbox" title="Select all" /></th>
                <th>#</th>
                <th>Timestamp</th>
                <th>Lat</th>
                <th>Lng</th>
                <th>Accuracy</th>
                <th>Device</th>
                <th>Link</th>
              </tr>
            </thead>
            <tbody id="secretTbody">
              {% include 'admin_tbody.html' %}
            </tbody>
          </table>
        </div>
      </div>

  <div class="mt-4 flex items-center justify-between">
        <div class="text-sm text-slate-600">Showing {{ data|length }} of {{ total }} records</div>
        <div class="flex items-center gap-2">
          {% if page > 1 %}
            <a href="?page={{ page-1 }}" class="px-3 py-1 bg-slate-100 rounded">← Prev</a>
          {% else %}
            <span class="px-3 py-1 text-slate-400">← Prev</span>
          {% endif %}
          <div class="flex items-center gap-1">
            {% for p in range(1, total_pages+1) %}
              {% if p == page %}
                <span class="px-3 py-1 bg-indigo-600 text-white rounded">{{ p }}</span>
              {% else %}
                <a href="?page={{ p }}" class="px-3 py-1 bg-slate-100 rounded">{{ p }}</a>
              {% endif %}
            {% endfor %}
          </div>
          {% if page < total_pages %}
            <a href="?page={{ page+1 }}" class="px-3 py-1 bg-slate-100 rounded">Next →</a>
          {% else %}
            <span class="px-3 py-1 text-slate-400">Next →</span>
          {% endif %}
        </div>
      </div>
    </main>

  <div id="pvToast" class="pv-toast" role="status" aria-live="polite"></div>
  <!-- confirmation modal for destructive actions -->
  <div id="pvConfirm" class="fixed inset-0 bg-black/40 hidden items-center justify-center z-50">
    <div class="bg-white rounded-lg shadow-lg max-w-md w-full p-6">
      <h3 class="text-lg font-semibold">Confirm action</h3>
      <p class="mt-2 text-sm text-slate-600">This will permanently clear the deleted archive and cannot be undone. Are you sure?</p>
      <div class="mt-4 flex items-center justify-end gap-3">
        <button id="pvConfirmCancel" class="px-3 py-1 bg-slate-100 rounded">Cancel</button>
        <button id="pvConfirmOk" class="px-3 py-1 bg-red-600 text-white rounded">Clear archive</button>
      </div>
    </div>
  </div>
  <script>
    // small client-side refresher: poll /table-meta and fetch /table-body when changed
    (function(){
      let lastMeta = { total: 0, newest: '' };
      // toggle control
      const toggleBtn = document.getElementById('autoRefreshToggle');
      function refreshEnabled(){ try{ return localStorage.getItem('pv_auto_refresh') !== '0'; }catch(e){ return true; } }
      function setRefresh(enabled){
        try{ localStorage.setItem('pv_auto_refresh', enabled ? '1' : '0'); }catch(e){}
        if(!toggleBtn) return;
        toggleBtn.setAttribute('aria-checked', enabled ? 'true' : 'false');
        toggleBtn.setAttribute('aria-pressed', enabled ? 'true' : 'false');
        const bg = toggleBtn.querySelector('.toggle-bg');
        const knob = toggleBtn.querySelector('.toggle-knob');
        if(enabled){
          if(bg) bg.classList.remove('bg-slate-200'); bg.classList.add('bg-indigo-600');
          if(knob) knob.classList.remove('translate-x-0'); knob.classList.add('translate-x-5');
        } else {
          if(bg) bg.classList.remove('bg-indigo-600'); bg.classList.add('bg-slate-200');
          if(knob) knob.classList.remove('translate-x-5'); knob.classList.add('translate-x-0');
        }
      }
      if(toggleBtn){
        // initialize state
        setRefresh(refreshEnabled());
        toggleBtn.addEventListener('click', ()=>{ setRefresh(!refreshEnabled()); });
      }

  async function check(){
        if(!refreshEnabled()) return;
        try{
          const r = await fetch('/table-meta', { cache: 'no-store' });
          if(!r.ok) return;
          const m = await r.json();
          if(m.total !== lastMeta.total || m.newest !== lastMeta.newest){
            lastMeta = m;
            const params = new URLSearchParams(window.location.search);
            const page = params.get('page') || '1';
            const b = await fetch('/table-body?page='+encodeURIComponent(page), { cache: 'no-store' });
            if(b.ok){
              const txt = await b.text();
              // parse the tbody rows
              const parser = new DOMParser();
              const doc = parser.parseFromString('<table>'+txt+'</table>', 'text/html');
              const newTbody = doc.querySelector('table');
              const tb = document.getElementById('secretTbody');
              if(tb && newTbody && tb.innerHTML.trim() !== newTbody.innerHTML.trim()){
                tb.innerHTML = newTbody.innerHTML;
                // update selection UI after DOM swap
                try{ updateSelectionUI(); }catch(e){}
                const toast = document.getElementById('pvToast');
                if(toast){ toast.textContent = 'Table refreshed'; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'), 1600); }
              }
            }
          }
        }catch(e){}
      }
      (async ()=>{ try{ const r = await fetch('/table-meta', { cache: 'no-store' }); if(r.ok) lastMeta = await r.json(); }catch(e){} })();
      setInterval(check, 5000);
      document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) check(); });
      // Delete selected handler
      const deleteBtn = document.getElementById('deleteSelected');
      async function refreshTable(){
        try{
          const params = new URLSearchParams(window.location.search);
          const page = params.get('page') || '1';
          const b = await fetch('/table-body?page='+encodeURIComponent(page), { cache: 'no-store' });
          if(b.ok){
            const txt = await b.text();
            const parser = new DOMParser();
            const doc = parser.parseFromString('<table>'+txt+'</table>', 'text/html');
            const newTbody = doc.querySelector('table');
            const tb = document.getElementById('secretTbody');
            if(tb && newTbody){ tb.innerHTML = newTbody.innerHTML; }
          }
        }catch(e){}
      }
      // selection helpers: keep header checkbox, per-row checkboxes and Delete button in sync
      function updateSelectionUI(){
        const selectAll = document.getElementById('selectAllChk');
        const deleteBtn = document.getElementById('deleteSelected');
        const checks = Array.from(document.querySelectorAll('.record-chk'));
        const checked = checks.filter(c=>c.checked);
        // update header checkbox state
        if(selectAll){
          if(checks.length === 0){ selectAll.indeterminate = false; selectAll.checked = false; }
          else if(checked.length === checks.length){ selectAll.indeterminate = false; selectAll.checked = true; }
          else if(checked.length === 0){ selectAll.indeterminate = false; selectAll.checked = false; }
          else { selectAll.indeterminate = true; selectAll.checked = false; }
        }
        // enable/disable delete button
        if(deleteBtn){ deleteBtn.disabled = checked.length === 0; if(checked.length === 0) deleteBtn.classList.add('opacity-60','cursor-not-allowed'); else deleteBtn.classList.remove('opacity-60','cursor-not-allowed'); }
      }
      // when header checkbox toggled, toggle visible row checkboxes
      const selectAllChk = document.getElementById('selectAllChk');
      if(selectAllChk){
        selectAllChk.addEventListener('change', function(){
          const checks = Array.from(document.querySelectorAll('.record-chk'));
          checks.forEach(c=>{ c.checked = !!selectAllChk.checked; });
          updateSelectionUI();
        });
      }
      // delegate change events from row checkboxes
      document.addEventListener('change', function(e){
        if(e.target && e.target.classList && e.target.classList.contains('record-chk')){
          updateSelectionUI();
        }
      });
      // ensure selection UI is correct after a manual refresh or initial load
      (function(){ try{ updateSelectionUI(); }catch(e){} })();
      if(deleteBtn){
        deleteBtn.addEventListener('click', async function(){
          const checks = Array.from(document.querySelectorAll('.record-chk:checked'));
          if(!checks.length) return alert('No rows selected');
          if(!confirm('Delete '+checks.length+' selected record(s)?')) return;
          const timestamps = checks.map(c=>c.dataset.ts).filter(Boolean);
          try{
            const res = await fetch('/delete-records', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ timestamps }) });
            if(res.ok){
              const j = await res.json();
              refreshTable();
              const toast = document.getElementById('pvToast');
              if(toast){
                const removed = (j.removed || 0);
                toast.innerHTML = removed + ' removed <button id="undoBtn" class="ml-3 text-sm text-indigo-200 underline">Undo</button>';
                toast.classList.add('show');
                const undo = document.getElementById('undoBtn');
                if(undo){
                  undo.addEventListener('click', async function(){
                    try{
                      await fetch('/undelete-records', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ timestamps: j.timestamps || [] }) });
                      refreshTable();
                      toast.textContent = 'Restored';
                      setTimeout(()=>toast.classList.remove('show'),1200);
                    }catch(e){ alert('Undo failed'); }
                  });
                }
                setTimeout(()=>{ if(toast) toast.classList.remove('show'); }, 8000);
              }
            }else{
              alert('Delete failed');
            }
          }catch(e){ alert('Delete failed'); }
        });
      }
      // clear deleted.json handler
      const clearBtn = document.getElementById('clearDeleted');
      // modal elements
      const pvConfirm = document.getElementById('pvConfirm');
      const pvConfirmCancel = document.getElementById('pvConfirmCancel');
      const pvConfirmOk = document.getElementById('pvConfirmOk');
      let clearCooldown = false;
      if(clearBtn){
        clearBtn.addEventListener('click', function(){
          if(clearCooldown) return; // disabled during cooldown
          // show modal
          if(pvConfirm) pvConfirm.classList.remove('hidden'); pvConfirm.classList.add('flex');
        });

        if(pvConfirmCancel){ pvConfirmCancel.addEventListener('click', function(){ if(pvConfirm){ pvConfirm.classList.add('hidden'); pvConfirm.classList.remove('flex'); } }); }

        if(pvConfirmOk){ pvConfirmOk.addEventListener('click', async function(){
          try{
            const res = await fetch('/clear-deleted', { method:'POST' });
            if(res.status === 429){
              const j = await res.json();
              const retry = j.retry_after || 60;
              alert('Rate limited. Try again in '+retry+'s');
              if(pvConfirm){ pvConfirm.classList.add('hidden'); pvConfirm.classList.remove('flex'); }
              return;
            }
            if(!res.ok) throw new Error('clear failed');
            const j = await res.json();
            const toast = document.getElementById('pvToast');
            if(toast){ toast.textContent = (j.removed_count || 0) + ' items cleared from archive'; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'),3000); }
            // cooldown on client to avoid rapid repeats
            clearCooldown = true; clearBtn.disabled = true; clearBtn.classList.add('opacity-50','cursor-not-allowed');
            setTimeout(()=>{ clearCooldown = false; clearBtn.disabled = false; clearBtn.classList.remove('opacity-50','cursor-not-allowed'); }, 10000);
          }catch(e){ alert('Failed to clear deleted archive'); }
          if(pvConfirm){ pvConfirm.classList.add('hidden'); pvConfirm.classList.remove('flex'); }
        }); }
      }
      // wire per-row delete buttons (also present in admin_tbody)
      document.addEventListener('click', function(e){
        if(!(e.target && e.target.classList && e.target.classList.contains('btn-delete-one'))){ return; }
        const ts = e.target.dataset.ts;
        if(!ts) return;
        if(!confirm('Delete this record?')) return;

        // handle delete with a named async function for clearer structure
        async function handleSingleDelete(timestamp){
          try{
            const res = await fetch('/delete-records', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ timestamps: [timestamp] })
            });
            if(!res.ok) throw new Error('delete failed');
            const j = await res.json();
            await refreshTable();
            const toast = document.getElementById('pvToast');
            if(!toast) return;
            toast.innerHTML = '1 removed <button id="undoBtn" class="ml-3 text-sm text-indigo-200 underline">Undo</button>';
            toast.classList.add('show');

            const undoBtn = document.getElementById('undoBtn');
            if(undoBtn){
              undoBtn.addEventListener('click', async function(){
                try{
                  await fetch('/undelete-records', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ timestamps: j.timestamps || [] })
                  });
                  await refreshTable();
                  toast.textContent = 'Restored';
                  setTimeout(()=>toast.classList.remove('show'), 1200);
                }catch(err){
                  alert('Undo failed');
                }
              });
            }
            setTimeout(()=>{ if(toast) toast.classList.remove('show'); }, 8000);
          }catch(err){
            alert('Delete failed');
          }
        }

        handleSingleDelete(ts);
      });
    })();
  </script>
  </body>
</html>
